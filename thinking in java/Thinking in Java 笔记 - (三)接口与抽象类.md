# Thinking in Java 笔记 - (三)接口、抽象类与内部类

## 接口与抽象类
### 关于接口方法签名
可以选择将接口中的方法声明为public，但是就算不写，他也是public的。所以在实现接口时，相应的方法必须声明为public，java不允许继承时降低父类方法访问权限。

### 为什么使用接口
一方面，使用接口可以向上转型成多个基类，带来一定的灵活性，同时能降低耦合。

另一方面，和抽象类相同，为了防止创建该类的对象。如果抽象基类不带任何方法定义和成员变量，可以选择将其声明为接口，当然，现在Java 8的接口已经支持默认方法了，所以在这里接口也可以带方法定义。

### TODO: p181

### 初始化接口中的域
接口中的域都是final，但是与普通的final不同的是，他必须被初始化，而不能是空白final

## 内部类
与C++不同，Java中的内部类不仅仅是一种命名方式，或者代码隐藏机制。内部类自动拥有对其外围类所有成员的访问权。准确的说，内部类对象有权访问外围对象的所有成员。

为了做到这一点，Java编译器有自己的机制。当外围类的对象创建了一个内部类对象时，内部类对象会获得一个该外围对象的引用。当通过内部类对象访问外围对象成员时，实际上是通过该引用来访问的。所以，内部类对象只能在与外围类对象关联的情况下才能创建。

### .this 与 .new
OuterClass.this可以指向外围类对象，而outerObj.new可以指定为哪个外围类对象创建内部类对象。

```java
public class Outer {
  class Inner {
    Outer outer() {
      return Outer.this;//指向外围类对象
    }
  }
  public static void main(String[] args) {
    Outer o = new Outer();
    Outer.Inner = o.new Inner();//为指定外围对象创建内部类对象
  }
}
```

### 内部类与向上转型
当内部类向上转型为基类，尤其是转型为一个接口时，便能体现其用武之地。因为得到的只是基类或接口的引用，其具体实现就能很容易的隐藏起来，比如容器的迭代器。

### 局部内部类与匿名内部类
局部内部类是在某个作用域或方法体内定义的内部类，而匿名内部类则用来创建一个继承自某个基类的匿名类的对象，并向上转型为该基类的引用。

局部内部类和匿名内部类可以访问所在代码块的静态变量以及所在对象的所有域，基本上可以作为闭包使用。

**tips**: 在局部内部类或匿名内部类的定义中，如果要使用所在作用域的变量，那个变量必须是final的。因为内部类一旦加载完毕，其变量初始化等操作用到的变量或引用（也就是下面例子中的a）就不会改变。所以一旦外部作用域内相关变量发生了改变，就会与这个局部内部类或匿名内部类的定义产生矛盾（*纯属个人理解*）。

```java
public class LocalInnerClass {
  public static void main(String[] args) {
    final int a = 1;
    Comparator c = new Comparator() {
      private int newInt = a;
    }
  }
}
```

当然，在匿名内部类的构造器中，可以使用外部作用域中非final的变量作为构造器参数。因为构造器调用并不是类的定义的一部分。

**tips**: 匿名内部类有一些限制，虽然它既可以扩展类，也可以实现接口，但是只能选择扩展基类或者实现某一个接口，而不能两者兼备。

而且，匿名内部类不能定义自己的构造器，因为它没有名字。。。不过，可以通过初始化代码块来实现构造器的工作。

### 使用内部类的理由
主要目的是用来实现“多重继承”。当然，如果基类都是接口的话，可以同时实现这些接口，但是基类有抽象类或具体的类，那么可能就需要内部类的机制了。此外，内部类还有以下好处：

- 内部类可以有多个实例，每个对象都与外围类相互独立
- 可以让多个内部类以不同的方式实现同一个接口，或继承同一个类
- 创建内部类对象的时刻并不依赖于外围类对象的创建
- 内部类没有多重继承中is-a的关系，他本身就是独立的实体

### 内部类标识符
内部类产生的.class文件名：OuterClass$InnerClass.class